---
title: Docker基础镜像小尝试
date: 2024-09-15 13:39:55
tags: Docker
---

构建 Docker 基础镜像时使用 "FROM scratch" 时镜像内到底是什么情况？这个环境内能运行什么文件？

rootfs？Linux 内核与 Linux 系统发行版各组件是什么关系？

<!--more-->

最近突然开始思考二进制文件在系统中究竟是怎么运行的。比如我用C++写了一个程序并编译为binary文件之后，运行它是不是只是需要将二进制文件中的01送入CPU就行了？

看来不是的。需要查阅两方面的内容。

1. C++程序的编译过程。预处理：展开宏、头文件、忽略注释之类的操作，生成处理之后的文件是文本文件，此时的头文件不再需要，因为已经在文件中被展开。编译：将处理好的文件翻译为汇编语言。汇编：将汇编语言转换为二进制文件。链接：将文件与其使用到的库文件链接在一起成为可执行文件。一个重要的概念是静态链接和动态链接。一般没有特意指定时都是动态链接。
2. Linux文件系统。内核能够完成一系列基础操作，比如内存管理、文件读写等，这些操作就是系统调用。而字符串操作等就不是系统调用。libc对外提供一系列API，大多数API都对应一个系统调用。libc库提供C语言中所使用的宏，类型定义，字符串操作函数，数学计算函数以及输入输出函数等。libc只是一种函数库标准，每个操作系统都会按照该标准对标准库进行具体实现，C/C++程序的运行需要有这些函数库的具体实现。这部分的[入门说明](https://blog.csdn.net/Erice_s/article/details/106184779)。这些libc库就是在rootfs中实现的，对应的系统调用由kernel完成。~~所谓的Linux发行版之间的区别也就是在rootfs的区别，~~（20241202-23:56 这篇文章有误导性，对于容器这么说没问题，但是对于一般的linux系统完全不是，因为二者的rootfs的作用不同。国内的文章真实转载来转载去。）这个论述是我在[这篇文章](https://www.cnblogs.com/winkey4986/p/8856945.html)中找到的，chatgpt也是这么说的，可以再多作求证。rootfs为了小体积可以只实现一些基础的功能，也可以提供十分丰富的功能。使用from scratch时的rootfs就没有libc，因此对于不是静态编译的C/C++程序也是不能运行的。

docker容器是需要调用Linux内核的，因此显然二进制文件需要是Linux环境中编译的，所以对于不配套的程序有执行错误完全正常。在Mac中编译的二进制程序在Linux环境中，至少对于简单的helloworld程序是可以正常运行的。在一个scratch镜像中也是如此，当然要是静态编译的。问题在于如果不是静态编译，报错会出现：`exec /hello: no such file or directory`。很奇怪，会说没有这个文件。这个问题在下面的前三篇文章中都有论述，据说是因为docker是用go语言写的，动态链接的C/C++程序不能直接运行。

下面的最后一篇文章中有讲到rootfs的问题，基本上跟上面的内容没有冲突。但是没有scratch镜像中rootfs的问题。但是这篇文章讲得挺详细的，虽然不知是不是转载，因为图片加载不了。

>在问ChatGPT“静态编译的C++程序能不能直接使用Linux内核运行”时，得到的回答如下：
>
>> ```markdown
>>静态编译的 C++ 程序可以在 Linux 内核上>>运行，但需要注意以下几点：
>>
>>### 1\. 静态编译的定义
>>
>>*   **静态编译**：将所有依赖的库（如 `libc`）直接编译到可执行文件中，而不是在运行时动态链接。这意味着生成的可执行文件不依赖于外部共享库。
>>
>>### 2\. 运行环境要求
>>
>>*   **Linux 内核**：静态编译的程序仍然需要在一个操作系统环境中运行，通常是一个 Linux 发行版。虽然程序本身是静态的，但它仍然需要操作系统提供的系统调用接口。
>>*   **系统调用**：程序在运行时会通过系统调用与内核交互，例如文件操作、网络通信等。这些系统调用是由 Linux 内核提供的。
>>
>>### 3\. 兼容性
>>
>>*   **ABI 兼容性**：静态编译的程序需要与运行它的 Linux 内核和用户空间的 ABI（应用程序二进制接口）兼容。不同的 Linux 发行版或内核版本可能会有不同的 ABI。
>>*   **库版本**：即使是静态编译，使用的库（如 `libc`）的版本也需要与目标系统兼容。
>>
>>### 4\. 使用场景
>>
>>*   **容器化应用**：静态编译的程序常用于 Docker 等容器环境中，因为它们可以减少依赖，简化部署。
>>*   **嵌入式系统**：在某些嵌入式系统中，静态编译的程序可以避免动态链接库的复杂性。
>>
>>### 5\. 注意事项
>>
>>*   **调试信息**：静态编译的程序可能会缺少某些调试信息，调试时可能会更加困难。
>>*   **体积**：静态编译的可执行文件通常比动态链接的文件大，因为它包含了所有依赖的库。
>>
>>### 总结
>>
>>静态编译的 C++ 程序可以在 Linux 内核上运行，但需要确保与目标系统的 ABI 兼容，并且仍然需要一个完整的操作系统环境来提供系统调用和其他必要的支持。
>>```
>>
>>提到了ABI的概念，可以学习一下。其实相当于是应用程序在底层的一种约定规则。
>
>gpt说from scratch的镜像没有rootfs。不知道。20241202-23:47 是的
>
>gpt很确定地说libc包含在rootfs中。不知道。20241202-23:47 对于linux来说不是的，但是对于容器是这样的

不错的参考文章：

- [创建尽可能小的 Docker 容器](https://segmentfault.com/a/1190000000628247)
- [Create the smallest possible Docker container](http://blog.xebia.com/2014/07/04/create-the-smallest-possible-docker-container/)
- [关于docker的scratch镜像与helloworld](https://www.cnblogs.com/uscWIFI/p/11917662.html)
- [docker（3、镜像1） base镜像构建基础](https://blog.csdn.net/cojn52/article/details/103161955)
- [创建自己的Docker基础镜像](https://www.cnblogs.com/cocowool/p/make_your_own_base_docker_image.html)
- [Docker 核心技术与实现原理](https://draveness.me/docker/)
-[Docker 进阶之镜像分层详解](https://developer.aliyun.com/article/981453)

镜像的几张图：

![alt text](../image/docker-image-build-try/85bd5dd3bfe7871ed67c37f55a586b0f.png)

![alt text](../image/docker-image-build-try/2017-11-30-docker-filesystems.png)

![alt text](../image/docker-image-build-try/97dd2455bde86096f7db5e5b42b25da5.png)

## 总结

就是说运行非静态编译的C程序需要libc库，libc库提供了API，这些API使用操作系统（Linux中的kernel）的系统调用与硬件沟通。docker镜像与宿主机共享kernel，而libc存在于rootfs中，是用户层的应用，当使用from scratch作为基础镜像时不包含rootfs，因此不能直接运行动态链接的C程序。

>这些东西主要牵扯到操作系统，计算机组成原理，编译原理这些底层的东西，还需要对Linux内核、系统的架构有一定的了解，而且需要知道docker的文件系统是怎么搭建的，容器的运行时原理以及架构等知识。比较庞大。
>
> 下面可以尝试用from scratch，然后加入libc库二进制，再试试看能不能运行动态链接的文件。

暂时先放下这个问题，因为很少要用from scratch。更多地关注系统、计算机原理层面的知识会是更好的选择。
