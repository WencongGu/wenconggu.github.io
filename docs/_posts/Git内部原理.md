---
title: Git内部原理
date: 2023-09-20 17:42:56
tags: Git
---

版本控制工具在实际开发中应该只是很小的一个工具，很多人应该都不会太关注它。但是其实如果稍微了解多一点，Git还是很有趣的。

<!-- more -->

## Git中的数据

### 对象数据

Git在设计数据存储模式时十分有智慧。Git 是一个内容寻址文件系统，听起来很酷。这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git 仓库中插入任意类型的内容，Git 会对存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算，会返回一个校验和，这就是这个数据文件的键，这个校验和一般是40位，通过该键可以在任意时刻再次取回该内容。而git会将这些键值对存储在 `.git/objects` 目录下，校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。

生成头部信息时，Git 首先会以识别出的对象的类型作为开头来构造一个头部信息，比如blob对象就是一个“blob”字符串，接着 Git 会在头部的第一部分添加一个空格，随后是数据内容的字节数，也就是大小信息，最后是一个空字节（null byte）。Git 会将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和。另两种对象类型的头部信息以字符串“commit”或“tree”开头。虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。

比如，在一个git仓库中添加一个文件 `1.txt`，内容为 `hello git`，可以使用 `git hash-object -w 1.txt`，其中 `-w` 参数表示将文件写入数据库。命令返回一个hash值，比如是 `8d0e41234f24b6da002d962a26c2495ea16a425f`，那么在 `.git/objects` 目录下就会存在一个 `8d/0e41234f24b6da002d962a26c2495ea16a425f` 文件，这个文件是保存着 `1.txt` 内容的有关信息。可以通过 `cat-file` 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 `cat-file` 指定 `-p` 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容。比如 `git cat-file -p 8d0e41234f24b6da002d962a26c2495ea16a425f` 输出会 `hello git`。
    
但是上面的操作中，文件名并没有被保存，我们仅保存了文件的内容。上述类型的对象我们称之为**数据对象**（**blob object**）。利用 `git cat-file -t` 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值。

### 树对象

**树对象**（**tree object**）能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象（tree）和数据对象（blob）的形式存储，其中树对象（tree）对应了 UNIX 中的目录项，数据对象（blob）则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录都包含一个SHA-1 值，这个哈希值或者指向数据对象（blob），或者指向子树对象（blob），这些记录还会包含相应的模式、类型、文件名等信息。

简单地讲，就是一个树对象相当于于git存储结构中的目录，但是这个目录并不真的存储文件，而是存储了blob对象和其对应的文件名等信息，当然还可以存储子目录。

一个典型的tree对象如图所示：

![alt text](image/Git-Objects/image.png)

这里的 `lib` 记录就是指向另一个tree对象的指针，也就是这个tree对象的hash值。一个目录中的子目录都会被存储为子树。

通常，Git 根据某一时刻的暂存区（即 `index` 区域，下同）来创建并记录一个对应的树对象。 因此，为创建一个树对象，首先需要暂存一些文件创建一个暂存区。 可以通过底层命令 `git update-index` 为一个单独文件创建一个暂存区。 利用该命令，可以文件人为地加入一个新的暂存区。 

在上一节我们认为地将 `1.txt`文件加入了git仓库中，要操作这个文件，必须为上述命令指定 `--add` 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）； 同样必需的还有 `--cacheinfo` 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。 同时，需要指定文件模式、SHA-1 与文件名。命令示例如下：

```bash
git update-index --add --cacheinfo 100644 \
  8d0e41234f24b6da002d962a26c2495ea16a425f test.txt
```

我们指定的文件模式为 100644，表明这是一个普通文件，不过多介绍这些。现在，可以通过 `git write-tree` 命令将暂存区内容写入一个树对象。命令返回一个hash值，可以使用 `git cat-file -p` 命令查看这个树对象的内容，或者使用 `git cat-file` 命令验证一下它确实是一个树对象。还可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。 通过调用 `git read-tree` 命令，可以把树对象读入暂存区，通过指定 `--prefix` 选项将已有的树对象作为子树读入暂存区，并命名。

### 提交对象

当我们构建好了tree对象后，技术上就可以根据每个tree的hash值来完整地重现项目，这个项目就是构建tree对象时所用的项目快照。但是tree对象包含的信息也太少了，比如我们希望知道每次构建时的作者、时间，对于构建者来说还可能想要保存构建原因、修改内容等信息，这些tree对象都不包含。

而以上这些，正是**提交对象**（**commit object**）能为你保存的基本信息。

可以通过调用 `commit-tree` 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。这个命令通过指定 `-p` 参数来引用一个提交对象（hash值）作为父对象。

提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照； 然后是可能存在的父提交； 之后是作者/提交者信息（依据你的 `user.name` 和 `user.email` 配置来设定，外加一个时间戳）； 留空一行，最后是提交注释。

每次我们运行 git add 和 git commit 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象、更新暂存区、记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。这三种主要的 Git 对象，数据对象、树对象、提交对象，最初均以单独文件的形式保存在 `.git/objects` 目录下。

一个可能的提交示意图比如：

![alt text](<image/Git-Objects/image copy.png>)

这张图显示出这样的历史：第一次提交时向仓库中保存了 `test.txt` 文件，构建起一个tree对象，创建一个提交对象注释为 `first commit`；第二次提交前新建了一个 `new.txt` 文件，并修改了 `test.txt` 文件得到第2个版本，二者构建起一个tree对象，创建了一个提交对象注释为 `second commit`；第三次提交前在缓存区加入第一次提交的tree对象，作为 `bak` 子树构建起一个新的tree对象，创建了一个提交对象注释为 `third commit`。通常情况下子树都是一个目录的子目录。
    
## Git引用

在git仓库中，我们常常对某一个特定的提交感兴趣，除了使用这个提交的hash值，我们还可以使用一个**引用**（**reference**，简写为**refs**）文件来指向这个提交。

可以在 .git/refs 目录下找到这类含有 SHA-1 值的文件。 这个目录包含了一个简单的目录结构：

```bash
$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
```

### 本地引用

若要创建一个新引用，从技术上讲我们只需将某个提交的hash值写入一个文件中，这个文件名就是引用名。可以简单地做如下操作：

```bash
$ echo 1a410ef > .git/refs/heads/myrefs
```

现在就可以在 Git 命令中使用这个新引用来代替 SHA-1 值了。但是不提倡直接编辑引用文件，如果想更新某个引用，Git 提供了一个更加安全的命令 `update-ref` 来完成此事：

```bash
$ git update-ref refs/heads/master 1a410ef
```
这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。若想在第二个提交上创建一个分支，可以这么做：

```bash
$ git update-ref refs/heads/test cac0ca
```

此时的git数据库基本如下所示：

![alt text](<image/Git-Objects/image copy 2.png>)

当运行类似于 `git branch <branch>` 这样的命令时，Git 实际上会运行 `update-ref` 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。

### HEAD引用

问题是如何获取当前最新提交的 hash 值。答案是HEAD引用，就是 `.git/HEAD` 文件。HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。

查看这个文件内容为：`ref: refs/heads/master`，表示当前所处的「最新提交」是 `refs/heads/master` 所指向的提交。所谓「最新」，不见得是时间上的最新，而仅仅是我们希望在这个提交的基础上进行操作。

不过在分离头指针的情况下，这个文件的内容也会变成一个提交的hash值。不作过多讨论。

当我们执行 `git checkout newbranch` 命令时，Git 会将 HEAD 文件内容更新为 `ref: refs/heads/newbranch`。
  
也可以使用 `git symbolic-ref` 命令来修改HEAD引用的值。

### 标签引用

我们知道git可以设置标签（tag）。实际上标签也是git中的一种对象。 标签对象（tag object） 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。

标签对象也像其他三种对象一样在 `.git/objects` 中按相似的规则存储，即以40位的hash值作为目录，其中存放着名为其他38位数字的文件。不过在 `.git/refs/tags` 目录下还会存放一个文件，这个文件是标签值，其内容是标签对象对应的提交对象的hash值。当然标签对象不一定指向提交对象，也可以指向树对象（tree）或者数据对象（blob）。

### 远程引用

还有一种引用是远程引用（remote reference）。 远程引用是 Git 用来表示来自其他仓库的引用的一种方式。 

如果你添加了一个远程版本库并对其执行过推送操作，或者clone了一个仓库，Git 会记录下最近一次操作时每一个分支所对应的值，并保存在 `.git/refs/remotes` 目录下。

例如，你可以添加一个叫做 origin 的远程版本库，然后把 master 分支推送上去，使用 `git remote add origin git@github.com:schacon/simplegit-progit.git && git push origin master` 命令，此时在 `.git/refs/remotes` 目录下会多出一个 `origin` 目录，其中存放着一个名为 `master` 的文件，其内容就是 origin 远程版本库的 master 分支所对应的 SHA-1 值。

远程引用和分支（位于 `.git/refs/heads` 目录下的引用）之间最主要的区别在于，远程引用是只读的。因此，你永远不能通过 commit 命令来更新远程引用。Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。

## 小问题

>我在查阅官方文档时，对远程引用的介绍中有这样一句话：「虽然可以 `git checkout` 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。」我不太清楚，如果不移动HEAD引用，那么如何 `checkout` 到这个引用？怎么判定当前引用的？有什么实际效果吗？还是说只是可以运行这个命令，但是实际没有任何改变？
>>20240410解答：很简单的问题，当初没有仔细看。所谓「虽然可以 `git checkout` 到某个远程引用」就是指HEAD可以指向远程引用指向的提交对象，但是不会指向那个远程引用，也就是说此时的HEAD引用处于分离头指针的状态。可以将HEAD checkout 到远程refs，但是与一般的checkout操作不同的是，此时的HEAD不会指向那个refs，所以文档中说「但是 Git 并不会将 HEAD 引用指向该远程引用。」，实际是直接指向那个refs指向的提交。破案！